# SQLite3 建库方案（优化版）

## 一、核心配置与并发控制

### 1. 基础配置（确保并发读写性能）
```sql
-- 启用WAL模式（Write-Ahead Logging）
-- 支持多进程并发读，写操作不阻塞读操作
PRAGMA journal_mode = WAL;

-- 设置同步模式为NORMAL
-- 平衡数据安全性与写入性能，崩溃时可能丢失最后一次写入但不损坏数据库
PRAGMA synchronous = NORMAL;

-- 启用内存缓存（根据实际内存调整，单位：页，默认每页4KB）
PRAGMA cache_size = -20000;  -- 负号表示KB，此处为20MB

-- 禁用自动检查点（由程序手动控制，避免高频写入时的性能波动）
PRAGMA wal_autocheckpoint = 0;
```


## 二、表结构设计（含版本控制）

```sql
-- 1. 数据库版本控制表（用于跟踪结构变更）
CREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER PRIMARY KEY,
    applied TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    description TEXT NOT NULL  -- 记录版本变更说明
);

-- 初始化版本（首次创建）
INSERT OR IGNORE INTO schema_version (version, description) 
VALUES (1, '初始表结构：用户、项目、问题及关联表');


-- 2. 用户表
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    birthday TEXT,
    prefs JSON,  -- 学习偏好等结构化数据
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 3. 项目表
CREATE TABLE IF NOT EXISTS projects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    short_goal TEXT,
    long_goal TEXT,
    features JSON,  -- 重点功能等
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 4. 问题记录表
CREATE TABLE IF NOT EXISTS issues (
    id TEXT PRIMARY KEY,  -- 自定义ID（如ts-bug-001）
    project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    example TEXT,  -- 关联示例
    context TEXT,  -- 问题上下文
    problem TEXT NOT NULL,  -- 问题描述
    cause TEXT,  -- 原因分析
    solution TEXT NOT NULL,  -- 解决方案
    verified INTEGER CHECK (verified IN (0,1)) DEFAULT 0,  -- 0未验证/1已验证
    last_updated TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    code_blocks JSON,  -- 关联代码块
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 5. 标签关联表（多对多）
CREATE TABLE IF NOT EXISTS issue_tags (
    issue_id TEXT NOT NULL REFERENCES issues(id) ON DELETE CASCADE,
    tag TEXT NOT NULL,
    PRIMARY KEY (issue_id, tag)
);

-- 6. 来源关联表（多对多）
CREATE TABLE IF NOT EXISTS issue_sources (
    issue_id TEXT NOT NULL REFERENCES issues(id) ON DELETE CASCADE,
    source TEXT NOT NULL,  -- 来源链接或描述
    PRIMARY KEY (issue_id, source)
);


-- 索引优化（针对高频查询场景）
CREATE INDEX IF NOT EXISTS idx_issues_project_id ON issues(project_id);
CREATE INDEX IF NOT EXISTS idx_issues_verified ON issues(verified);
CREATE INDEX IF NOT EXISTS idx_issue_tags_tag ON issue_tags(tag);
CREATE INDEX IF NOT EXISTS idx_issues_last_updated ON issues(last_updated);
```


## 三、连接池与事务策略（多线程/进程环境）

### 1. 连接池实现（Python示例）
```python
import sqlite3
from queue import Queue
import threading

class SQLiteConnectionPool:
    def __init__(self, db_path, max_connections=5):
        self.db_path = db_path
        self.max_connections = max_connections
        self.pool = Queue(max_connections)
        
        # 初始化连接池
        for _ in range(max_connections):
            conn = sqlite3.connect(db_path)
            conn.execute("PRAGMA journal_mode = WAL;")
            conn.execute("PRAGMA synchronous = NORMAL;")
            conn.row_factory = sqlite3.Row  # 支持按列名访问
            self.pool.put(conn)
    
    def get_connection(self):
        """获取连接（阻塞直到有可用连接）"""
        return self.pool.get()
    
    def release_connection(self, conn):
        """释放连接回池（需确保事务已提交/回滚）"""
        if conn:
            self.pool.put(conn)
    
    def close_all(self):
        """关闭所有连接"""
        while not self.pool.empty():
            conn = self.pool.get()
            conn.close()

# 使用示例
pool = SQLiteConnectionPool("memory.db")
conn = pool.get_connection()
try:
    # 执行操作
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM issues LIMIT 1;")
finally:
    pool.release_connection(conn)
```

### 2. 事务优化（批量操作）
```sql
-- 批量插入示例（减少I/O次数）
BEGIN TRANSACTION;

INSERT INTO issues (id, project_id, problem, solution)
VALUES 
('batch-001', 1, '问题1', '解决方案1'),
('batch-002', 1, '问题2', '解决方案2'),
('batch-003', 1, '问题3', '解决方案3');

-- 批量插入标签
INSERT INTO issue_tags (issue_id, tag)
VALUES 
('batch-001', 'bug'),
('batch-001', 'python'),
('batch-002', 'feature');

COMMIT;  -- 一次性写入磁盘
```


## 四、监控与归档策略

### 1. 数据量监控（定期执行）
```sql
-- 检查issues表行数（超过阈值时触发归档）
SELECT COUNT(*) AS issue_count FROM issues;

-- 查看表空间占用
SELECT 
    name AS table_name,
    (pgno * 4096) AS size_bytes  -- 假设页大小4096字节
FROM sqlite_master 
JOIN pragma_page_count(name) ON 1=1
WHERE type = 'table';
```

### 2. 归档方案（当issue_count > 10万行时）
```sql
-- 1. 创建历史表（按年份分表）
CREATE TABLE IF NOT EXISTS issues_2024 (
    LIKE issues INCLUDING ALL  -- 复制原表结构
);

-- 2. 迁移旧数据（例如：2024年之前的数据）
INSERT INTO issues_2024
SELECT * FROM issues 
WHERE last_updated < '2025-01-01' 
AND project_id = 1;  -- 按项目归档

-- 3. 删除原表中已归档的数据
DELETE FROM issues 
WHERE last_updated < '2025-01-01' 
AND project_id = 1;

-- 4. 重建索引（归档后优化性能）
REINDEX idx_issues_project_id;
```

### 3. 表结构演进管理
```sql
-- 示例：新增字段时更新版本
-- 1. 创建新版本记录
INSERT INTO schema_version (version, description)
VALUES (2, 'issues表新增priority字段');

-- 2. 执行结构变更
ALTER TABLE issues ADD COLUMN priority INTEGER DEFAULT 3;  -- 3为默认优先级

-- 回滚方案（如需降级）
-- ALTER TABLE issues DROP COLUMN priority;
-- DELETE FROM schema_version WHERE version = 2;
```


## 五、使用规范总结
1. **并发控制**：始终启用WAL模式，多进程环境使用连接池（避免多进程同时打开同一数据库文件）。
2. **事务管理**：单条操作可自动提交，批量操作必须手动包裹事务（BEGIN/COMMIT）。
3. **性能维护**：
   - 定期执行`PRAGMA wal_checkpoint(TRUNCATE);`清理WAL日志
   - 数据量增长后按规则归档，避免单表过大
4. **版本跟踪**：每次修改表结构必须更新`schema_version`，记录变更说明。

该方案兼顾了轻量性与可扩展性，既适合初期小数据量场景，也能通过归档和索引优化应对数据膨胀。