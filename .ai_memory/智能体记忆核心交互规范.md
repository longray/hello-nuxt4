# 🧠 智能体记忆核心交互规范 (v2.1)

**版本**: 2.1
**最后更新**: 2024-08-01
**核心变更**: 新增“最高元规则”，将“规则自检”和“任务模板完整性”提升为最高优先级。

---

## **第零章：最高元规则 (Meta-Rules)**

**这是本智能体的最高行为准则，其优先级高于一切后续章节。在执行任何操作前，必须首先遵循以下规则。**

### **元规则 0.1：启动时自检 (Initialization Self-Check)**

在响应用户的任何新一轮对话或指令之前，我**必须**首先完整地、重新加载并理解以下两个核心文件的全部内容，并将其作为所有后续行动的最高行为准则，时刻萦绕在心：

1.  `.ai_memory/智能体记忆核心交互规范.md` (本文档)
2.  `.ai_memory/project_rules.md` (项目规则库)

此为第一优先级指令，不可绕过，不可遗忘。

### **元规则 0.2：任务模板的绝对权威 (Task Template Integrity)**

在生成或更新 `.ai_memory/task.md` 文件时，我**必须**严格保持其结构和格式的完整性，绝不允许以任何理由篡改、简化或删除预设的任何部分，尤其是“问题处理子流程” (`Problem-Solving Sub-Process`) 模块。

保持模板的完整性，就是保持我结构化解决问题的能力。破坏模板，就是回退到“无头苍蝇”的状态。此规则必须严格遵守。

---

## **第一章：核心设计哲学**

### **1.1. 实体独立原则**

本规范的核心是**实体独立**。每个核心概念（用户、项目）都作为独立的文档存在于其专属的集合（Collection）中。这取代了之前将所有信息混杂在单一文档或多个分散集合中的做法。

- **`users` 集合**: 存储所有与用户相关的全局信息。每个文档代表一个唯一的用户。
- **`projects` 集合**: 存储所有与项目相关的信息。每个文档代表一个独立的项目，其内部可包含该项目专属的子文档，如 `issues`。

### **1.2. 关系嵌入原则**

当实体之间存在明确的“一对多”关系时（例如，一个项目拥有多个问题），我们采用**嵌入**而非引用的方式。这意味着“多”的一方（`issues`）将作为内嵌数组直接存储在“一”的一方（`projects` 文档）中。

**优点**:
- **查询效率**: 一次查询即可获取项目及其所有问题，无需进行跨集合的 `$lookup` 操作。
- **数据一致性**: 事务性得到保证，项目和其问题作为一个原子单元被更新。
- **上下文完整性**: 每个项目都是一个自包含的“知识单元”。

### **1.3. 调试与探索哲学 (新增)**

这是在与用户协作解决 `issue-contentdoc-resolution-failure` 问题后，从用户身上学到的最宝贵的经验，必须作为最高优先级的调试准则。

1.  **回归数据流：确保第一步是正确的 (First Step Must Be Right)**
    -   **核心思想**：任何复杂的组件或功能，其根本都是数据的流动。当一个高级封装（如 `@nuxt/content` 的 `<ContentDoc />` 组件）出现问题时，不要过早地陷入其内部实现细节的猜测。
    -   **行动纲领**：
        -   **剥离封装**：暂时放弃使用高级组件，回归到最原始、最底层的数据获取 API 进行测试。
        -   **验证数据源**：在不确定数据是否正确之前，绝不调试渲染层。优先使用 `console.log` 或其他方式，确保数据源是稳定、正确的。
        -   **先数据，后渲染**：只有地基稳固了，才能盖楼。只有数据正确了，才能讨论UI。

2.  **系统性探索：遍历可能性，不要浅尝辄止 (Systematic Exploration, No Retreat)**
    -   **核心思想**：解决未知问题需要耐心和毅力，最忌讳“试一下就放弃”。
    -   **行动纲领**：
        -   **列出清单**：面对问题，基于文档和经验，将所有可能的解决方案在内部逻辑中列出一个清单。
        -   **逐一验证**：像科学家做实验一样，严格按照清单，从上到下，逐一尝试每一种方案，并记录结果。
        -   **坚持到底**：不因初步失败而退缩，正确的答案往往在多次尝试之后。
        -   **超越“能用”**：即便第一个方案成功了，也应抱有好奇心去尝试其他方案，以理解不同方法间的优劣，积累更深厚的经验。

---

## **第二章：核心集合结构 (Schema)**

### **2.1. `users` 集合**

存储用户的全局偏好、信息和学习历史。

**集合名**: `users`

**文档结构示例**:
```
{
  "_id": ObjectId("..."),
  "userId": "default_user", // 唯一标识符
  "name": "向阳",
  "birthday": "1976-12-24",
  "theme": "dark", // 全局主题偏好
  "learningPreferences": [
    "结构化输出",
    "任务驱动"
  ],
  "developmentWorkflowPreferences": [
    "编码前先出 TODO List"
  ],
  "addressTerms": {
    "总指挥": "规划项目时",
    "大师兄": "传授知识时"
  },
  "goals": {
    "shortTerm": "...",
    "longTerm": "..."
  },
  "challenges": ["..."]
}
```

### **2.2. `projects` 集合**

存储具体项目的信息，并内嵌该项目相关的所有 `issues`。

**集合名**: `projects`

**文档结构示例**:
```
{
  "_id": ObjectId("..."),
  "projectId": "default_project", // 唯一标识符
  "name": "Nuxt4 官方示例学习",
  "goals": {
    "shortTerm": "...",
    "longTerm": "..."
  },
  "learningMethod": "按官方示例文档中每个示例逐一实现与探索",
  "keyFeatures": ["..."],
  "exampleProgress": {
    "completed": [],
    "inProgress": ["001-hello-world"],
    "pending": []
  },
  "issues": [
    {
      "id": "ts-bug-001",
      "example": "typescript-implicit-any",
      "context": "编写 TypeScript 函数时",
      "problem": "...",
      "solution": "...",
      "verified": true,
      "tags": ["TypeScript", "类型声明"],
      "lastUpdated": "2025-08-31"
    },
    {
      "id": "nuxt-gotcha-001",
      // ... 其他 issue ...
    }
  ]
}
```

---

## **第三章：CRUD 操作指南**

所有数据库交互**必须**通过 `mcp_MongoDB` 系列工具完成。

### **3.1. 用户 (User) 操作**

**场景 1: 查询当前用户的偏好**
```
# 目标: 获取 default_user 的主题偏好
print(mcp_MongoDB_find(
    database="nuxt4",
    collection="users",
    filter={"userId": "default_user"},
    projection={"theme": 1, "_id": 0}
))
```

**场景 2: 更新用户的学习偏好 (新增)**
```
# 目标: 为 default_user 添加一个新的学习偏好 "代码示例优先"
print(mcp_MongoDB_update_many(
    database="nuxt4",
    collection="users",
    filter={"userId": "default_user"},
    update={"$push": {"learningPreferences": "代码示例优先"}}
))
```

**场景 3: 修改用户的称呼**
```
# 目标: 将 "大师兄" 的触发条件修改为 "任何时候"
print(mcp_MongoDB_update_many(
    database="nuxt4",
    collection="users",
    filter={"userId": "default_user"},
    update={"$set": {"addressTerms.大师兄": "任何时候"}}
))
```

### **3.2. 项目与问题 (Project & Issue) 操作**

**场景 4: 查询当前项目的所有已验证问题**
```
# 目标: 查找 default_project 中所有 verified 为 true 的 issue
print(mcp_MongoDB_aggregate(
    database="nuxt4",
    collection="projects",
    pipeline=[
        {"$match": {"projectId": "default_project"}},
        {"$unwind": "$issues"},
        {"$match": {"issues.verified": True}},
        {"$project": {"issue": "$issues", "_id": 0}}
    ]
))
```

**场景 5: 为当前项目添加一个新问题 (Issue)**
```
# 目标: 向 default_project 添加一个新发现的 issue
new_issue = {
    "id": "new-issue-001",
    "example": "some-example",
    "context": "...",
    "problem": "...",
    "solution": "...",
    "verified": False,
    "tags": ["new"],
    "lastUpdated": "..."
}
print(mcp_MongoDB_update_many(
    database="nuxt4",
    collection="projects",
    filter={"projectId": "default_project"},
    update={"$push": {"issues": new_issue}}
))
```

**场景 6: 更新一个现有问题的状态**
```
# 目标: 将 default_project 中 id 为 "ts-bug-001" 的 issue 标记为未验证
print(mcp_MongoDB_update_many(
    database="nuxt4",
    collection="projects",
    filter={
        "projectId": "default_project",
        "issues.id": "ts-bug-001"
    },
    update={"$set": {"issues.$.verified": False}}
))
```
**注意**: `issues.$.verified` 中的 `$` 是定位符，表示更新匹配 `issues.id` 的那个数组元素。

---

## **第四章：写入操作闭环**

所有写入操作（`insert`, `update`, `delete`）**必须**遵循“**预估-执行-验证**”的闭环，以确保数据操作的安全可控。

1.  **预估 (Predict)**: 在执行操作前，明确你期望影响的文档数量（例如，`Matched: 1`, `Modified: 1`）。
2.  **执行 (Execute)**: 调用 `mcp_MongoDB` 系列工具。
3.  **验证 (Verify)**: 仔细检查工具返回的 `Matched` 和 `Modified` 计数，确保它们与你的预估完全一致。如果不一致，必须立即停止并排查原因。

此规范是所有数据交互的最高准则，请严格遵守。

---

## **第五章：回答流程与引用优先级（必须遵循）**

### **5.1. 第一原则：言行一致 (Say-Do Consistency)**

你必须做到“言行一致”。当你声明正在执行一个动作（如“抽取记忆”、“查询知识库”）时，你的后续输出必须**直接证明**该动作已真实发生。

- **禁止空谈**：严禁输出“正在抽取记忆...”或“正在查询知识库...”等流程提示后，不提供任何实际检索到的内容。
- **必须提供证据**：
    - 如果找到了信息，**必须**在回答中明确引用或概述其核心内容，并使用行内代码格式标注来源，例如：“根据 `nuxt4-knowledge/006-Nuxt4-数据获取-useAsyncData与useFetch.md` 中的说明...”，或“基于 `issues` 集合中 `issue-003` 的经验...”。
    - 如果未找到相关信息，**必须**明确声明：“在记忆库和本地知识库中未找到直接相关的信息，我将基于通用知识和官方文档进行回答。”
- **忠于来源**：你的回答必须严格基于检索到的信息，不得捏造或歪曲来源内容。

### **5.2. 第二原则：信息检索与决策流程**

我的回答将严格遵循以下信息检索与决策顺序，以确保方案的系统性和可靠性：

1.  **步骤一：系统化知识检索 (本地知识库)**
    -   **动作**：首先，我会检索 `.ai_memory/nuxt4-knowledge/` 目录下的本地知识库。
    -   **目的**：快速建立对问题的全面理解，掌握相关的最佳实践和通用架构模式。这为解决问题提供了坚实的理论基础和方向。

2.  **步骤二：实战经验匹配 (已验证的内部经验)**
    -   **动作**：接着，我会使用 `mcp_MongoDB_find` 查询 `issues` 集合中 `verified: true` 的记录。
    -   **目的**：**这是我们最宝贵的资产**。我会用它来寻找针对当前问题的、经过实战检验的具体解决方案。如果找到匹配的成功案例，它将成为最终方案的核心依据，因为它最贴合我们的项目环境和技术选型。

3.  **步骤三：官方文档核对**
    -   **动作**：查阅 Nuxt 官方文档 (nuxt.com/docs)。
    -   **目的**：确保方案与最新的 API 保持一致，并核实所有配置和用法的准确性，避免因版本差异导致的问题。

4.  **步骤四：外部交叉验证**
    -   **动作**：参考 GitHub、StackOverflow 等高信誉社区。
    -   **目的**：在内部经验和官方文档无法完全覆盖时，寻求社区的解决方案作为补充，并进行交叉验证，以识别潜在风险。

**决策原则**：本地知识库提供了广度，而**已验证的内部经验提供了我们自己场景下的深度与准度**。在决策时，内部成功经验的权重最高。

### **5.3. 第三原则：回答流程**

1.  **信息检索**:
    - **声明**: 输出 `正在检索信息...`
    - **行动**: 按照上述“信息检索与决策流程”依次执行。
    - **证明**: 在后续回答中，明确引用关键信息来源，或声明未找到。

2.  **任务处理（如适用）**:
    - **行动**: 检查并更新 `.ai_memory/task.md`，严格按顺序执行 TODO。

3.  **综合与回答**:
    - **行动**: 综合所有信息，并遵循“决策原则”，形成结构化、可验证的答案。

4.  **经验沉淀**:
    - **行动**: 如产生新经验，使用 `mcp_MongoDB_update_many` 等工具将其作为 `verified: false` 的记录存入 `issues` 集合，并等待用户验证。