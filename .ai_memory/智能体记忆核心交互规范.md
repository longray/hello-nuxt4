# 🧠 智能体记忆核心交互规范 (v2.0)

**版本**: 2.0
**最后更新**: 2024-08-01
**核心变更**: 数据库架构从“混合存储”升级为“多集合独立实体”模型。

---

## **第一章：核心设计哲学**

### **1.1. 实体独立原则**

本规范的核心是**实体独立**。每个核心概念（用户、项目）都作为独立的文档存在于其专属的集合（Collection）中。这取代了之前将所有信息混杂在单一文档或多个分散集合中的做法。

- **`users` 集合**: 存储所有与用户相关的全局信息。每个文档代表一个唯一的用户。
- **`projects` 集合**: 存储所有与项目相关的信息。每个文档代表一个独立的项目，其内部可包含该项目专属的子文档，如 `issues`。

### **1.2. 关系嵌入原则**

当实体之间存在明确的“一对多”关系时（例如，一个项目拥有多个问题），我们采用**嵌入**而非引用的方式。这意味着“多”的一方（`issues`）将作为内嵌数组直接存储在“一”的一方（`projects` 文档）中。

**优点**:
- **查询效率**: 一次查询即可获取项目及其所有问题，无需进行跨集合的 `$lookup` 操作。
- **数据一致性**: 事务性得到保证，项目和其问题作为一个原子单元被更新。
- **上下文完整性**: 每个项目都是一个自包含的“知识单元”。

---

## **第二章：核心集合结构 (Schema)**

### **2.1. `users` 集合**

存储用户的全局偏好、信息和学习历史。

**集合名**: `users`

**文档结构示例**:
```
{
  "_id": ObjectId("..."),
  "userId": "default_user", // 唯一标识符
  "name": "向阳",
  "birthday": "1976-12-24",
  "theme": "dark", // 全局主题偏好
  "learningPreferences": [
    "结构化输出",
    "任务驱动"
  ],
  "developmentWorkflowPreferences": [
    "编码前先出 TODO List"
  ],
  "addressTerms": {
    "总指挥": "规划项目时",
    "大师兄": "传授知识时"
  },
  "goals": {
    "shortTerm": "...",
    "longTerm": "..."
  },
  "challenges": ["..."]
}
```

### **2.2. `projects` 集合**

存储具体项目的信息，并内嵌该项目相关的所有 `issues`。

**集合名**: `projects`

**文档结构示例**:
```
{
  "_id": ObjectId("..."),
  "projectId": "default_project", // 唯一标识符
  "name": "Nuxt4 官方示例学习",
  "goals": {
    "shortTerm": "...",
    "longTerm": "..."
  },
  "learningMethod": "按官方示例文档中每个示例逐一实现与探索",
  "keyFeatures": ["..."],
  "exampleProgress": {
    "completed": [],
    "inProgress": ["001-hello-world"],
    "pending": []
  },
  "issues": [
    {
      "id": "ts-bug-001",
      "example": "typescript-implicit-any",
      "context": "编写 TypeScript 函数时",
      "problem": "...",
      "solution": "...",
      "verified": true,
      "tags": ["TypeScript", "类型声明"],
      "lastUpdated": "2025-08-31"
    },
    {
      "id": "nuxt-gotcha-001",
      // ... 其他 issue ...
    }
  ]
}
```

---

## **第三章：CRUD 操作指南**

所有数据库交互**必须**通过 `mcp_MongoDB` 系列工具完成。

### **3.1. 用户 (User) 操作**

**场景 1: 查询当前用户的偏好**
```
# 目标: 获取 default_user 的主题偏好
print(mcp_MongoDB_find(
    database="nuxt4",
    collection="users",
    filter={"userId": "default_user"},
    projection={"theme": 1, "_id": 0}
))
```

**场景 2: 更新用户的学习偏好 (新增)**
```
# 目标: 为 default_user 添加一个新的学习偏好 "代码示例优先"
print(mcp_MongoDB_update_many(
    database="nuxt4",
    collection="users",
    filter={"userId": "default_user"},
    update={"$push": {"learningPreferences": "代码示例优先"}}
))
```

**场景 3: 修改用户的称呼**
```
# 目标: 将 "大师兄" 的触发条件修改为 "任何时候"
print(mcp_MongoDB_update_many(
    database="nuxt4",
    collection="users",
    filter={"userId": "default_user"},
    update={"$set": {"addressTerms.大师兄": "任何时候"}}
))
```

### **3.2. 项目与问题 (Project & Issue) 操作**

**场景 4: 查询当前项目的所有已验证问题**
```
# 目标: 查找 default_project 中所有 verified 为 true 的 issue
print(mcp_MongoDB_aggregate(
    database="nuxt4",
    collection="projects",
    pipeline=[
        {"$match": {"projectId": "default_project"}},
        {"$unwind": "$issues"},
        {"$match": {"issues.verified": True}},
        {"$project": {"issue": "$issues", "_id": 0}}
    ]
))
```

**场景 5: 为当前项目添加一个新问题 (Issue)**
```
# 目标: 向 default_project 添加一个新发现的 issue
new_issue = {
    "id": "new-issue-001",
    "example": "some-example",
    "context": "...",
    "problem": "...",
    "solution": "...",
    "verified": False,
    "tags": ["new"],
    "lastUpdated": "..."
}
print(mcp_MongoDB_update_many(
    database="nuxt4",
    collection="projects",
    filter={"projectId": "default_project"},
    update={"$push": {"issues": new_issue}}
))
```

**场景 6: 更新一个现有问题的状态**
```
# 目标: 将 default_project 中 id 为 "ts-bug-001" 的 issue 标记为未验证
print(mcp_MongoDB_update_many(
    database="nuxt4",
    collection="projects",
    filter={
        "projectId": "default_project",
        "issues.id": "ts-bug-001"
    },
    update={"$set": {"issues.$.verified": False}}
))
```
**注意**: `issues.$.verified` 中的 `$` 是定位符，表示更新匹配 `issues.id` 的那个数组元素。

---

## **第四章：写入操作闭环**

所有写入操作（`insert`, `update`, `delete`）**必须**遵循“**预估-执行-验证**”的闭环，以确保数据操作的安全可控。

1.  **预估 (Predict)**: 在执行操作前，明确你期望影响的文档数量（例如，`Matched: 1`, `Modified: 1`）。
2.  **执行 (Execute)**: 调用 `mcp_MongoDB` 系列工具。
3.  **验证 (Verify)**: 仔细检查工具返回的 `Matched` 和 `Modified` 计数，确保它们与你的预估完全一致。如果不一致，必须立即停止并排查原因。

此规范是所有数据交互的最高准则，请严格遵守。