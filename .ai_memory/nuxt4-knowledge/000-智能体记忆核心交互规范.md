# 000-智能体记忆核心交互规范

本篇文档记录了与项目记忆核心 (`memory.db`) 交互时必须遵循的最佳实践，以确保数据的完整性与一致性。

## 核心原则：始终开启外键约束

**问题 (Problem):**

在 SQLite 3.6.19 之前的版本，以及 `sqlite3` 命令行工具的默认设置中，外键约束 (`FOREIGN KEY constraints`) 是默认关闭的。

这意味着，即使表结构中定义了 `ON DELETE CASCADE` 级联删除规则，当从主表删除一条记录时，关联子表中的记录 **不会** 被自动删除，从而产生孤儿数据 (Orphaned Data)，破坏了记忆核心的完整性。

**根源 (Cause):**

这是 SQLite 为了向后兼容而做出的设计选择。

**解决方案 (Solution):**

在执行任何可能触发外键约束的操作（如 `DELETE`, `UPDATE`）之前，必须在 **同一个数据库连接会话** 中，首先执行以下命令来显式开启外键约束：

---

### 附录 B：数据库 Schema 校验与同步

为确保作为“单一事实来源”的 `schema.sql` 文件始终与 `memory.db` 数据库的实际结构保持一致，需要定期进行校验和同步。

1.  **导出实时 Schema**：
    使用以下 PowerShell 命令可以导出当前 `memory.db` 的完整结构：

    ```powershell
    $sqlCommand = '.schema'
    $sqlCommand | .\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db
    ```

2.  **比对与更新**：
    将上述命令的输出结果与 `.ai_memory/schema.sql` 文件的内容进行比对。

    - 如果发现数据库中存在 `schema.sql` 未定义的表（如 `schema_version`），或表结构有差异，应手动将这些变更更新到 `schema.sql` 文件中。
    - `sqlite_sequence` 是 SQLite 内部表，可以忽略。

通过此流程，可以保证我们的数据库“设计蓝图”和“实体”是完全同步的。sql
PRAGMA foreign_keys = ON;
```

---

## 自动化实践：使用封装脚本与标准输入

为了从根本上解决外键约束和命令行参数转义这两个核心问题，我们确立了以下的最佳实践：**使用 `sqlite3-fk.cmd` 脚本，并通过标准输入（stdin）传递复杂的 SQL 语句**。

**目的:**

所有助理在与 `memory.db` 进行交互时，**必须** 遵循此规范。

**工作原理:**

1.  **`sqlite3-fk.cmd`**: 这个由您（用户）提供的脚本，在启动 `sqlite3.exe` 时，通过 `-cmd` 参数自动执行 `PRAGMA foreign_keys = ON;`，确保外键约束始终开启。
2.  **标准输入 (stdin)**: 对于包含引号、JSON 等复杂字符的 SQL 语句，我们使用 PowerShell 的管道符 `|` 将其作为纯净的文本流传递给 `sqlite3-fk.cmd`。这完全绕过了 PowerShell 和 `cmd.exe` 复杂的参数转义机制，保证了 SQL 语句的完整性。

**使用方法:**

```powershell
# 示例：使用管道方式插入一条包含 JSON 的复杂记录
# 1. 将 SQL 语句存储在 PowerShell 变量中，保持其可读性。
$sql = "INSERT INTO users (name, preferences, goals, challenges) VALUES ('testuser-02', '["dark_mode", "show_hidden_files"]', '{"short_term": "Complete CRUD test", "long_term": "Build a robust memory system"}', '["Handle PowerShell quoting issues"]');"

# 2. 通过管道将变量内容传递给封装脚本。
$sql | .\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db

# 示例：对于不包含复杂字符的简单查询，可以直接作为参数传递
.\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db "SELECT * FROM users;"
```

通过这套组合拳，我们将规则固化为了代码和流程，确保了记忆核心交互的健壮性与长期健康。

---

## 记忆核心 CRUD 自检流程 (小抄)

本章节提供了一套标准的增删查改 (Create, Read, Update, Delete) 操作命令，用于快速验证记忆核心 (`memory.db`) 的健康状态。

**测试数据ID:** `test-crud-001`

### 1. 增 (Create) - 插入一条完整的测试记录

```powershell
# 使用管道插入一条完整的 issue 记录，包含主表、标签和来源
$sql_create = "
INSERT INTO issues (id, example, context, problem, cause, solution, code, verified, last_updated) VALUES ('test-crud-001', 'self-check', 'CRUD-test', 'Problem description', 'Cause analysis', 'Solution steps', 'console.log(\"hello world\")', 0, DATE('now'));
INSERT INTO issue_tags (issue_id, tag) VALUES ('test-crud-001', 'test-tag-1'), ('test-crud-001', 'test-tag-2');
INSERT INTO issue_sources (issue_id, source) VALUES ('test-crud-001', 'internal-test');
"
$sql_create | .\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db
```

### 2. 查 (Read) - 读取并验证插入的记录

```powershell
# 查询主表、标签和来源，一次性执行多条语句
$sql_read = "
SELECT * FROM issues WHERE id = 'test-crud-001';
SELECT * FROM issue_tags WHERE issue_id = 'test-crud-001';
SELECT * FROM issue_sources WHERE issue_id = 'test-crud-001';
"
$sql_read | .\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db
```

### 3. 改 (Update) - 更新记录并验证

```powershell
# 更新 verified 状态和 problem 描述
$sql_update = "UPDATE issues SET verified = 1, problem = 'Problem description (updated)' WHERE id = 'test-crud-001';"
$sql_update | .\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db

# 验证更新结果
.\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db "SELECT id, problem, verified FROM issues WHERE id = 'test-crud-001';"
```

### 4. 删 (Delete) - 删除主记录并验证级联删除

```powershell
# 删除主记录
.\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db "DELETE FROM issues WHERE id = 'test-crud-001';"

# 验证所有相关记录（主表和关联表）均已被级联删除
$sql_verify_delete = "
SELECT * FROM issues WHERE id = 'test-crud-001';
SELECT * FROM issue_tags WHERE issue_id = 'test-crud-001';
SELECT * FROM issue_sources WHERE issue_id = 'test-crud-001';
"
$sql_verify_delete | .\.ai_memory\sqlite3-fk.cmd .\.ai_memory\memory.db
```