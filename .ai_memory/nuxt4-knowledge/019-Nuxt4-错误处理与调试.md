# Nuxt4 错误处理与调试
标签: Nuxt4, 错误处理, 调试, Bugfix

## 问题描述
在开发和生产环境中，如何优雅地处理 Nuxt4 应用中可能出现的各种错误？例如，如何捕获 Vue 组件的渲染错误、API 请求失败、服务端错误等？如何创建一个全局的错误展示页面？以及有哪些高效的调试技巧？

## 解决方案
Nuxt4 提供了一套完整的错误处理机制，覆盖了从服务端到客户端的整个生命周期。

### 1. 全局错误页面 (`error.vue`)
这是处理所有未被捕获的错误（无论是服务端还是客户端）的最终防线。在项目根目录创建一个 `error.vue` 文件，它将自动接管错误展示。

```vue
<!-- error.vue -->
<template>
  <div class="flex flex-col items-center justify-center min-h-screen bg-gray-100">
    <h1 class="text-6xl font-bold text-red-500">{{ error.statusCode }}</h1>
    <p class="text-2xl mt-4">{{ errorMessage }}</p>
    <p class="mt-2 text-gray-600">{{ error.message }}</p>
    <button @click="handleError" class="mt-8 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
      返回首页
    </button>
  </div>
</template>

<script setup>
const props = defineProps({
  error: Object
});

const errorMessage = computed(() => {
  switch (props.error.statusCode) {
    case 404:
      return "哎呀，页面找不到了！";
    case 500:
      return "服务器开小差了，请稍后再试。";
    default:
      return "发生了一些未知错误。";
  }
});

// 清除错误并重定向
const handleError = () => clearError({ redirect: '/' });
</script>
```
**关键点**:
- **`props.error`**: 该组件接收一个 `error` prop，包含了错误信息，如 `statusCode`, `message`, `statusMessage`, `data` 等。
- **`clearError`**: 这是一个必须调用的函数，用于清除当前的错误状态并导航到新的页面。

### 2. 编程式错误处理

#### a. `createError`
在任何地方（组件、插件、API 路由）都可以调用 `createError` 来触发一个全屏的错误页面。

```typescript
// 在页面或组件中
const { data, error } = await useFetch('/api/protected-data');
if (error.value) {
  // 如果 API 返回 403 Forbidden
  if (error.value.statusCode === 403) {
    throw createError({
      statusCode: 403,
      statusMessage: '无权访问',
      message: '您没有权限查看此内容。'
    });
  }
  // 处理其他错误...
}
```

#### b. `showError`
`showError` 是 `createError` 的一个别名，功能完全相同。

### 3. Vue 错误处理

#### a. `onErrorCaptured` (组件内)
在组件内部，可以使用 `onErrorCaptured` 生命周期钩子来捕获来自子组件的错误。

```vue
<script setup>
import { onErrorCaptured } from 'vue';

onErrorCaptured((err, instance, info) => {
  console.error("子组件发生错误:", err, info);
  // 返回 false 可以阻止错误向上传播
  return false;
});
</script>
```

#### b. 全局 Vue 错误处理 (插件)
可以创建一个插件来设置一个全局的 Vue 错误处理器。

```typescript
// plugins/vue-error-handler.ts
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.config.errorHandler = (error, instance, info) => {
    // 在这里处理错误，例如上报给 Sentry, LogRocket 等
    console.log("Vue 全局错误:", error);
    
    // 你也可以在这里决定是否向用户显示一个通知
  };
});
```

### 4. 调试技巧

#### a. Nuxt DevTools
Nuxt 4 内置了强大的开发者工具，默认在开发模式下启用。它提供了：
-   **页面和路由检查**: 查看所有路由和页面组件。
-   **组件检查**: 查看项目中所有组件的层级和 props。
-   **组合式函数 (Composables)**: 查看 `useState`, `useFetch` 等的状态。
-   **模块和插件**: 查看已安装的模块和插件。
-   **Payload 和数据**: 检查从服务端传递到客户端的数据。

#### b. VSCode 调试
配置 VSCode 的 `launch.json` 文件，可以实现对 Nuxt 服务端代码的断点调试。

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Nuxt App",
      "program": "${workspaceFolder}/node_modules/nuxi/bin/nuxi.mjs",
      "args": ["dev"],
      "console": "integratedTerminal"
    }
  ]
}
```

#### c. 日志记录
-   在服务端，可以直接使用 `console.log`，日志会输出到运行 `npm run dev` 的终端。
-   在客户端，日志会输出到浏览器的开发者工具控制台。
-   对于更复杂的日志需求，可以集成如 `pino` 或 `winston` 等日志库。

## 常见坑点与注意事项

-   **`error.vue` 的限制**:
    -   `error.vue` 是一个“自给自足”的页面，它不使用任何布局（Layout）。确保它的样式和脚本是独立的，不要依赖外部的布局或插件。

-   **Hydration Mismatch 错误**:
    -   这是 Nuxt (以及其他 SSR 框架) 中最常见的错误之一。它发生在服务端渲染的 HTML 和客户端首次渲染的 HTML 不匹配时。
    -   **常见原因**: 在 `onMounted` 之外的地方使用了仅客户端可用的 API（如 `window`, `localStorage`），或者在模板中基于非响应式数据进行了条件渲染。
    -   **解决方案**: 使用 `<ClientOnly>` 组件包裹仅客户端的组件，或将相关逻辑移至 `onMounted` 钩子中。

-   **在 `useFetch` 中处理错误**:
    -   `useFetch` 返回的 `error` ref 是一个响应式对象。直接在模板中使用它，或者在 `<script setup>` 中 `watch` 它来触发副作用（如显示 toast 通知），而不是立即 `throw createError`，这样可以提供更友好的用户体验。

-   **生产环境的错误上报**:
    -   在生产环境中，应该将捕获到的错误信息发送到专业的错误监控服务（如 Sentry, Bugsnag, LogRocket）。这可以在全局错误处理插件中实现。

## 核心调试哲学：回归数据流与系统性探索

在 Nuxt 4 中遇到问题时，尤其是看似棘手的“组件不渲染”、“数据不显示”等问题，应遵循以下两个核心哲学：

### 1. 回归数据流：确保第一步是正确的

任何复杂的组件或功能，其根本都是数据的流动。当一个高级封装（如 `@nuxt/content` 的 `<ContentDoc />` 组件）出现问题时，不要过早地陷入其内部实现细节的猜测。

**正确的做法是：**

- **剥离封装**：暂时放弃使用高级组件，回归到最原始、最底层的数据获取 API 进行测试。
- **验证数据源**：在 `@nuxt/content` 的案例中，这意味着直接在 `<script setup>` 中使用 `queryContent()` API，并用 `console.log` 打印结果，确保你**能拿到数据**。
- **先数据，后渲染**：只有确保了数据源是稳定、正确的，再去考虑如何将它渲染到页面上。这能将问题的范围缩小一半，极大地提高调试效率。

> **[info] 案例复盘**
> 在 `issue-contentdoc-resolution-failure` 中，我们最初纠结于 `<ContentDoc />` 组件为何无法解析，但最终的解决方案证明，问题的关键在于如何正确地**获取数据**，而不是如何**使用组件**。一旦通过 `useAsyncData` + `queryContent` 成功拿到数据，渲染问题便迎刃而解。

### 2. 系统性探索：遍历可能性，不要浅尝辄止

当面对一个未知问题时，官方文档、社区帖子或过往经验通常会提供多种可能的解决方案。此时，最忌讳的就是“试一下就放弃”。

**正确的做法是：**

- **列出清单**：将所有可能的解决方案在脑中或纸上列出一个清单。
- **逐一验证**：像科学家做实验一样，严格按照清单，从上到下，逐一尝试每一种方案。
- **记录结果**：每尝试一种方案，都要清晰地记录下结果（成功、失败、新的错误信息等）。
- **坚持到底**：不要因为第一个方案失败就感到挫败或退缩。很多时候，正确的答案就在第二个或第三个尝试之中。问题的解决需要耐心和毅力。
- **超越“能用”**：即便第一个方案成功了，也应该抱有好奇心去尝试其他方案。这能帮助你理解不同方法之间的优劣，积累更深厚的经验，从而在未来的技术选型中做出更明智的决策。

这种系统性的、不轻言放弃的探索精神，是区分普通工程师和资深专家的重要标志。

---

## 参考链接
-   [Nuxt4 官方文档 - 错误处理](https://nuxt.com/docs/getting-started/error-handling)
-   [Nuxt4 官方文档 - `useError`](https://nuxt.com/docs/api/composables/use-error)
-   [Nuxt4 官方文档 - `clearError`](https://nuxt.com/docs/api/utils/clear-error)
-   [Vue.js 官方文档 - 错误处理](https://vuejs.org/guide/error-handling.html)