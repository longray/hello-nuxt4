{
  "用户": {
    "姓名": "向阳",
    "生日": "1976-12-24",
    "学习偏好": [
      "结构化输出",
      "任务驱动",
      "中文偏好，如有需要可中英双语讲解"
    ],
    "开发流程偏好": [
      "编码前先出 TODO List，并保存到 .ai_memory/task.md 文件中，变更被审批通过后更新 TODO List；如被拒绝，不更新",
      "编码前先查看 .ai_memory/task.md 文件中的 TODO List，确保任务未被其他助手修改",
      "编码前进行自我审查"
    ],
    "称呼协议": {
      "总指挥": "规划项目时",
      "大师兄": "传授知识时",
      "领航员": "探索新技术时",
      "拆弹专家": "调试 Bug 时",
      "代码艺术家": "代码重构或优化时",
      "老司机": "日常指导时"
    },
    "目标": {
      "短期": "通过重写 Nuxt4 示例深化理解与实战能力",
      "长期": "打造 AI + 人类协作的技术学习生态系统"
    },
    "挑战": [
      "确保 AI 严格执行 TODO List",
      "在自动化与可读性之间取得平衡"
    ]
  },
  "项目": {
    "名称": "Nuxt4 官方示例学习",
    "目标": {
      "短期": "通过逐步模仿并实现官方示例，掌握 Nuxt4 核心功能",
      "长期": "构建完整的 Nuxt4 应用开发知识体系"
    },
    "学习方式": "按官方示例文档中每个示例逐一实现与探索",
    "重点功能": [
      "页面渲染 (SSR/CSR/ISR)",
      "数据获取 (asyncData, fetch)",
      "状态管理 (Pinia)",
      "布局与路由",
      "插件与中间件",
      "性能优化"
    ],
    "示例进度": {
      "已实现": [],
      "进行中": [],
      "待开始": []
    }
  },
  "issues": [
    {
      "id": "ts-bug-001",
      "example": "typescript-implicit-any",
      "context": "编写 TypeScript 函数时",
      "problem": "函数参数未声明类型导致 “implicitly has an 'any' type” 错误",
      "solution": "为所有函数参数显式声明类型，如 `(name: string)`",
      "verified": true,
      "tags": [
        "TypeScript",
        "类型声明"
      ],
      "lastUpdated": "2025-08-31"
    },
    {
      "id": "nuxt-gotcha-001",
      "example": "server-directory-location",
      "context": "Nuxt4 项目结构中 server 目录位置",
      "problem": "将 server 目录放在 srcDir 下导致 API 路由加载失败",
      "solution": "必须将 `server/` 目录放置在项目根目录",
      "verified": true,
      "tags": [
        "Nuxt4",
        "server",
        "API 路由"
      ],
      "lastUpdated": "2025-09-01"
    },
    {
      "id": "dev-workflow-001",
      "example": "general-dev-process",
      "context": "在 Nuxt 开发服务器运行时修改前端代码",
      "problem": "修改前端代码后不必要地重启服务器，导致开发效率降低且应用状态丢失。",
      "solution": "利用 Nuxt 内置的热模块替换（HMR）功能。在编辑前端文件（如 .vue, .css）后，无需重启服务器，变更会自动在浏览器中生效。",
      "verified": true,
      "tags": ["HMR", "dev-workflow", "Nuxt4"],
      "sources": ["用户口述经验"],
      "lastUpdated": "2024-07-29"
    },
    {
      "id": "ui-theme-001",
      "example": "hello-world",
      "context": "在 `pages/index.vue` 中为 `<pre>` 标签设置背景色",
      "problem": "使用固定的背景色（如 `bg-gray-100`）在暗色主题下会导致文本（白色）和背景（浅灰色）对比度不足，内容难以辨认。",
      "cause": "硬编码的颜色无法根据系统的 `color-scheme` 或用户的主题偏好自动调整。",
      "solution": "使用 `@nuxtjs/color-mode` 模块和 Tailwind CSS 的 `dark:` 变体来定义主题感知的颜色。例如，可以设置为 `bg-gray-100 dark:bg-gray-800`，这样在亮色模式下背景为浅灰，在暗色模式下背景为深灰，确保任何主题下都有良好的可读性。",
      "verified": true,
      "tags": ["Nuxt4", "TailwindCSS", "dark-mode", "theming"],
      "sources": [
        "https://tailwindcss.com/docs/dark-mode",
        "https://color-mode.nuxtjs.org/"
      ],
      "lastUpdated": "2024-07-30"
    },
    {
      "id": "workflow-rule-001",
      "example": "all",
      "context": "在开始一个新的 Nuxt 示例之前",
      "problem": "上一个示例的残留文件（如页面、API 路由、组件）可能会对新示例产生非预期的影响，干扰新功能的验证和学习。",
      "solution": "在开始每个新示例之前，执行‘清理房间’操作：删除 `pages/`, `server/api/`, `components/`, `layouts/` 等目录中与上一个示例相关的文件。保持工作区的整洁，确保每个示例都在一个干净、隔离的环境中进行。",
      "verified": true,
      "tags": ["workflow", "best-practice", "project-setup"],
      "sources": ["用户口述经验"],
      "lastUpdated": "2024-07-30"
    },
    {
      "id": "meta-template-001",
      "example": "meta-tags-with-template",
      "context": "在 Nuxt4 中同时使用全局 titleTemplate 和页面的 meta 信息",
      "problem": "使用 `definePageMeta` 设置的页面 `title` 无法与 `nuxt.config.ts` 中定义的全局 `app.head.titleTemplate` 正确合并，导致全局模板（如网站后缀）丢失。",
      "cause": "`definePageMeta` 是一个编译时宏 (Compile-time Macro)，它的值在构建打包阶段被静态地“雕刻”进路由元信息中，倾向于整体替换 (Override) 而非组合 (Compose)。而 `titleTemplate` 的合并逻辑发生在运行时 (Runtime)，由 Unhead 库处理。当 Unhead 发现一个静态设置的完整 `title` 时，它会优先使用该值，而不会再应用模板。相比之下，`useHead` 是一个运行时组合式函数 (Runtime Composable)，它在客户端/服务端渲染时动态地将 `title` 片段提供给 Unhead，Unhead 会识别出这是一个不完整的标题，并主动与其 `titleTemplate` 进行合并。",
      "solution": "当页面标题需要与全局 `titleTemplate` 结合时，必须使用 `useHead({ title: '页面标题' })` 来提供 `title`。对于其他不需要模板合并的静态元数据（如 `description`, `keywords`, `og:image` 等），仍然推荐使用 `definePageMeta`，因为它在编译时处理，有更好的性能。两者可以且应该结合使用，各司其职。",
      "code": {
        "nuxt.config.ts": "export default defineNuxtConfig({ app: { head: { titleTemplate: '%s - Nuxt4 大冒险' } } })",
        "pages/meta-static.vue (Incorrect for template)": "<script setup>\ndefinePageMeta({\n  title: '静态标题' // This will NOT be combined with titleTemplate\n})\n</script>",
        "pages/meta-runtime.vue (Correct for template)": "<script setup>\nuseHead({\n  title: '运行时标题' // This WILL be combined with titleTemplate\n})\n</script>"
      },
      "verified": true,
      "tags": ["Nuxt4", "SEO", "meta", "unhead", "definePageMeta", "useHead", "titleTemplate"],
      "sources": [
        "实践经验与对比实验",
        "nuxt4-knowledge/018-Nuxt4-SEO优化与Meta标签管理.md"
      ],
      "lastUpdated": "2024-07-31"
    },
    {
      "id": "data-fetching-001",
      "example": "fetching-page-example",
      "context": "在 `pages/fetching.vue` 中使用 `useFetch` 从一个会返回 HTML 的 API 获取数据",
      "problem": "页面直接渲染了返回的 HTML 字符串，而不是解析后的数据",
      "cause": "API `https://api.nuxtjs.dev/mountains` 返回的是 HTML 页面，而不是 JSON 数据。`useFetch` 默认期望 JSON 格式。",
      "solution": "更换 `useFetch` 的数据源为一个返回 JSON 的 API，例如 `https://jsonplaceholder.typicode.com/posts`，并相应地更新模板。",
      "code": "const { data: posts, pending, error } = await useFetch('https://jsonplaceholder.typicode.com/posts')",
      "verified": true,
      "tags": ["useFetch", "API", "JSON", "data-fetching"],
      "sources": [
        "nuxt4-knowledge/006-Nuxt4-数据获取-useAsyncData与useFetch.md",
        "https://jsonplaceholder.typicode.com/"
      ],
      "lastUpdated": "2024-07-27"
    },
    {
      "id": "data-fetching-002",
      "example": "fetching-page-example",
      "context": "在使用 `useFetch` 获取大量或格式不符合直接渲染需求的数据时，需要进行预处理。",
      "problem": "从 `jsonplaceholder.typicode.com/posts` 获取的原始数据过多（100条），且标题和内容格式不满足展示要求（例如需要大写、截断等）。",
      "cause": "原始 API 数据未经过处理直接绑定到模板上。",
      "solution": "使用 `useFetch` 的 `transform` 选项，在数据获取后、缓存前对数据进行处理。例如，截取前5条，将标题转为大写，并格式化内容。",
      "code": "const { data: posts } = useFetch('https://jsonplaceholder.typicode.com/posts', {\n  transform: (posts) => {\n    return posts.slice(0, 5).map(post => ({\n      ...post,\n      title: post.title.toUpperCase(),\n      body: `【中文翻译】${post.body.slice(0, 50)}...`\n    }))\n  }\n})",
      "verified": true,
      "tags": ["useFetch", "transform", "data-fetching", "performance"],
      "sources": [
        "nuxt4-knowledge/006-Nuxt4-数据获取-useAsyncData与useFetch.md",
        "https://nuxt.com/docs/api/composables/use-fetch#transform"
      ],
      "lastUpdated": "2024-07-28"
    },
    {
      "id": "data-fetching-003",
      "example": "fetching-page-example",
      "context": "在 `pages/fetching.vue` 中，数据获取会阻塞页面渲染，影响首屏加载速度。",
      "problem": "即使用户只需要先看到页面的基本结构，也必须等待 `useFetch` 数据完全加载后才能看到页面内容。",
      "cause": "默认情况下，`useFetch` 会在服务端阻塞渲染，直到数据获取完成。",
      "solution": "在 `useFetch` 中添加 `lazy: true` 选项。这会使数据获取在客户端进行，不会阻塞服务端的初始渲染。页面会先展示一个加载状态，数据加载完成后再更新视图。",
      "code": "const { data: posts, pending } = useFetch('...', { lazy: true })",
      "verified": true,
      "tags": ["useFetch", "lazy", "performance", "SSR", "CSR"],
      "sources": [
        "nuxt4-knowledge/017-Nuxt4-性能优化-代码分割与懒加载.md",
        "https://nuxt.com/docs/api/composables/use-fetch#lazy"
      ],
      "lastUpdated": "2024-07-28"
    },
    {
      "id": "data-fetching-004",
      "example": "fetching-page-example",
      "context": "用户在 `pages/fetching.vue` 页面上可能看到缓存的旧数据，需要一种方式来手动获取最新数据。",
      "problem": "`useFetch` 会缓存请求结果，当服务端数据更新时，客户端不会自动刷新。",
      "cause": "Nuxt 的内置缓存机制旨在提高性能，但需要手动干预才能刷新。",
      "solution": "从 `useFetch` 中解构出 `refresh` 函数，并将其绑定到一个按钮的点击事件上。调用 `refresh()` 会强制 `useFetch` 重新发起请求。",
      "code": "const { data, pending, refresh } = useFetch(...)\n\n<button @click=\"refresh\">刷新数据</button>",
      "verified": false,
      "tags": ["useFetch", "refresh", "cache", "data-fetching"],
      "sources": [
        "nuxt4-knowledge/006-Nuxt4-数据获取-useAsyncData与useFetch.md",
        "https://nuxt.com/docs/api/composables/use-fetch#refresh"
      ],
      "lastUpdated": "2024-07-28"
    },
    {
      "id": "ssr-fetch-default-001",
      "example": "fetching-v2-ssr-default",
      "context": "在 Nuxt SSR 模式下，为 `useFetch` 设置 `lazy: true` 和 `default` 选项，期望页面能立即展示 `default` 的占位数据，然后再异步更新为接口返回的真实数据。",
      "problem": "即使移除了 `await`，页面仍然会等待服务端接口返回（有2秒延迟），`default` 选项并未像预期那样立即显示。只有在 `useFetch` 中设置 `server: false`，完全禁用服务端数据获取时，`default` 选项才生效。",
      "cause": "这是 Nuxt 数据获取策略的预期行为。1. **`await useFetch` (阻塞式)**: 在 SSR 模式下，`await` 会强制 Nuxt 服务器等待数据获取完成后，才将最终渲染好的 HTML 发送给客户端。整个过程是同步阻塞的，因此 `default` 选项没有机会展示。 2. **`useFetch` without `await` (非阻塞式)**: 移除 `await` 并使用 `lazy: true`，意图是让服务器立即发送页面骨架，然后在客户端异步获取数据。然而，Nuxt 的同构（Isomorphic）特性使得 `useFetch` 默认仍会在服务端 *尝试* 发起请求。这个请求的状态（pending）会被序列化并传递到客户端。客户端的 `useFetch` 会“接管”这个正在进行中的请求，因此客户端依然会等待，`default` 值没有机会展示。 3. **`server: false`**: 这个选项明确告诉 `useFetch` ‘完全不要在服务端执行我’。因此，服务端渲染时会跳过这个数据获取，立即返回页面。客户端接管后，发现数据是 `null` 且没有正在进行的请求，于是它会：1) 立即使用 `default` 值进行初次渲染；2) 发起一个新的客户端请求去获取真实数据。",
      "solution": "如果需要 `default` 立即生效：必须在 `useFetch` 中设置 `server: false`，将数据获取完全转移到客户端。如果仍需 SSR 带来的 SEO 和首屏内容优势：接受 `await` 带来的阻塞，但通过优化 API 响应速度来减少等待时间。",
      "code": "const { data: post, pending } = useFetch('/api/post', {\n  lazy: true,\n  server: false, // 关键点：强制在客户端获取数据\n  default: () => ({\n    hitokoto: '正在加载一言...',\n    from: '程序'\n  })\n})",
      "verified": true,
      "tags": ["Nuxt4", "useFetch", "SSR", "default", "lazy", "server", "data-fetching"],
      "sources": [
        "实践经验与对比实验",
        "https://nuxt.com/docs/api/composables/use-fetch#server"
      ],
      "lastUpdated": "2024-07-31"
    }
  ]
}