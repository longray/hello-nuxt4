# Nuxt4 单元测试与端到端测试
标签: Nuxt4, 测试, Vitest, Playwright, 单元测试, E2E测试

## 问题描述
如何为 Nuxt4 应用设置和编写测试，以确保代码质量、功能稳定性和防止回归？如何对组件、组合式函数（Composables）进行单元测试？如何进行端到端（E2E）测试来模拟真实用户交互？

## 解决方案
Nuxt 社区推荐使用 `Vitest` 进行单元测试和组件测试，使用 `Playwright` 或 `Cypress` 进行端到端测试。官方提供了 `@nuxt/test-utils` 包来简化测试环境的搭建。

### 1. 环境搭建

**步骤一：安装依赖**
```bash
# Vitest 用于单元/组件测试, Playwright 用于 E2E 测试
npm install -D vitest @vue/test-utils @nuxt/test-utils playwright
```

**步骤二：配置 `vitest.config.ts`**
在项目根目录创建 `vitest.config.ts`。

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true, // 全局启用 describe, it, expect 等
    environment: 'nuxt', // 使用 @nuxt/test-utils 提供的 Nuxt 环境
    // 如果需要，可以包含/排除特定文件
    include: ['tests/**/*.test.ts'],
  },
});
```

**步骤三：添加 `package.json` 脚本**
```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui", // 使用 Vitest UI
    "test:e2e": "playwright test"
  }
}
```

### 2. 单元测试 (Unit Testing)
主要针对独立的函数、组合式函数（Composables）。

**示例：测试一个组合式函数**

```typescript
// composables/useCounter.ts
export const useCounter = () => {
  const count = ref(0);
  const increment = () => count.value++;
  const decrement = () => count.value--;
  return { count, increment, decrement };
};
```

```typescript
// tests/composables/useCounter.test.ts
import { describe, it, expect } from 'vitest';
import { useCounter } from '../../composables/useCounter';

describe('useCounter', () => {
  it('should initialize with count 0', () => {
    const { count } = useCounter();
    expect(count.value).toBe(0);
  });

  it('should increment count', () => {
    const { count, increment } = useCounter();
    increment();
    expect(count.value).toBe(1);
  });

  it('should decrement count', () => {
    const { count, decrement } = useCounter();
    decrement();
    expect(count.value).toBe(-1);
  });
});
```

### 3. 组件测试 (Component Testing)
使用 `@vue/test-utils` 来挂载组件并断言其行为。

**示例：测试一个简单的按钮组件**

```vue
<!-- components/MyButton.vue -->
<template>
  <button @click="emit('click')">{{ label }}</button>
</template>

<script setup>
const props = defineProps({ label: String });
const emit = defineEmits(['click']);
</script>
```

```typescript
// tests/components/MyButton.test.ts
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import MyButton from '../../components/MyButton.vue';

describe('MyButton', () => {
  it('renders the label', () => {
    const wrapper = mount(MyButton, {
      props: { label: '点击我' },
    });
    expect(wrapper.text()).toContain('点击我');
  });

  it('emits a click event', async () => {
    const wrapper = mount(MyButton);
    await wrapper.trigger('click');
    expect(wrapper.emitted()).toHaveProperty('click');
    expect(wrapper.emitted().click).toHaveLength(1);
  });
});
```

### 4. 端到端测试 (E2E Testing) with Playwright
E2E 测试在真实的浏览器环境中运行你的整个 Nuxt 应用，模拟用户从头到尾的操作流程。

**步骤一：初始化 Playwright**
Playwright 的配置通常是独立的。创建一个 `playwright.config.ts`。

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  webServer: {
    command: 'npm run dev', // 在测试前启动开发服务器
    url: 'http://localhost:3000', // 等待此 URL 可访问
    reuseExistingServer: !process.env.CI,
  },
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
    { name: 'webkit', use: { ...devices['Desktop Safari'] } },
  ],
});
```

**示例：测试一个简单的页面导航**

```typescript
// tests/e2e/navigation.spec.ts
import { test, expect } from '@playwright/test';

test('homepage has a title and a link to about page', async ({ page }) => {
  // 访问首页
  await page.goto('/');

  // 期望页面标题包含特定文本
  await expect(page).toHaveTitle(/My Nuxt App/);

  // 找到指向“关于”页面的链接并点击
  const aboutLink = page.getByRole('link', { name: 'About' });
  await aboutLink.click();

  // 期望 URL 变为 /about
  await expect(page).toHaveURL(/.*about/);

  // 期望新页面上有一个 H1 标题
  await expect(page.getByRole('heading', { name: 'About Us' })).toBeVisible();
});
```

## 常见坑点与注意事项

-   **Nuxt 环境模拟**: `@nuxt/test-utils` 的 `environment: 'nuxt'` 对于需要 Nuxt 上下文（如自动导入的组件、组合式函数 `useNuxtApp` 等）的测试至关重要。如果缺失，很多 Nuxt 特有的功能将无法在测试中使用。

-   **异步操作**: 在组件测试和 E2E 测试中，大量的操作都是异步的（如用户交互、DOM 更新、API 请求）。务必使用 `async/await` 来等待这些操作完成，否则你的断言可能会在状态更新之前执行，导致测试失败。

-   **模拟 (Mocking)**:
    -   在单元/组件测试中，你通常不希望发出真实的 API 请求。使用 `vi.mock` 来模拟整个模块或特定的函数。
    -   对于 `useFetch`，可以模拟 `$` 开头的组合式函数：
        ```typescript
        // tests/setup.ts (或测试文件顶部)
        import { vi } from 'vitest';

        vi.mock('#app', () => ({
          useFetch: vi.fn(() => Promise.resolve({ data: ref({ message: 'mocked' }) }))
        }));
        ```

-   **E2E 测试的选择器**: 
    -   避免使用脆弱的 CSS 类名或复杂的 XPath 作为选择器。优先使用 Playwright 推荐的、面向用户的选择器，如 `getByRole`, `getByText`, `getByLabel` 等。这使你的测试对代码重构更具弹性。
    -   对于无法通过常规方式定位的元素，可以使用 `data-testid` 属性作为最后的手段。

-   **CI/CD 集成**: 
    -   确保你的测试脚本可以在持续集成环境中无头（headless）运行。
    -   在 CI 配置文件（如 GitHub Actions workflow）中，分别设置运行单元测试和 E2E 测试的步骤。

## 参考链接
-   [Nuxt4 官方文档 - 测试](https://nuxt.com/docs/getting-started/testing)
-   [`@nuxt/test-utils` 文档](https://nuxt.com/modules/test-utils)
-   [Vitest 官方文档](https://vitest.dev/)
-   [Vue Test Utils 官方文档](https://test-utils.vuejs.org/)
-   [Playwright 官方文档](https://playwright.dev/docs/intro)