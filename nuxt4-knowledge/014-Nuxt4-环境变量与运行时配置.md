# Nuxt4 环境变量与运行时配置
标签: Nuxt4, 环境变量, 运行时配置, 配置管理

## 问题描述
在开发 Nuxt4 应用时，如何安全地管理不同环境（开发、测试、生产）的配置？如何处理敏感信息（如 API 密钥）？如何确保环境变量在服务端和客户端都能正确工作？这些都是构建可维护应用的关键问题。

## 解决方案
Nuxt4 提供了一个强大的运行时配置系统，它可以：
1. 安全地处理环境变量
2. 区分私有和公共配置
3. 在构建时和运行时都能正确工作
4. 支持类型安全

### 基础配置

#### 环境变量文件
在项目根目录创建环境变量文件：

```bash
# .env
NUXT_API_SECRET="你的私密API密钥"
NUXT_PUBLIC_API_BASE="https://api.example.com"
```

```bash
# .env.development
NUXT_PUBLIC_API_BASE="http://localhost:3001"
```

#### nuxt.config.ts 中的运行时配置
```typescript
export default defineNuxtConfig({
  runtimeConfig: {
    // 私有密钥（仅在服务端可用）
    apiSecret: '', // 可以通过 NUXT_API_SECRET 环境变量设置
    
    // 公共密钥（服务端和客户端都可用）
    public: {
      apiBase: '', // 可以通过 NUXT_PUBLIC_API_BASE 环境变量设置
      appName: '我的超棒应用',
      version: '1.0.0'
    }
  }
})
```

### 使用配置

#### 在组件中使用
```vue
<template>
  <div>
    <h1>{{ config.public.appName }}</h1>
    <p>版本: {{ config.public.version }}</p>
  </div>
</template>

<script setup>
const config = useRuntimeConfig()

// 注意：config.apiSecret 在客户端是 undefined
console.log('API Base:', config.public.apiBase)
</script>
```

#### 在服务端 API 中使用
```typescript
// server/api/secret.ts
export default defineEventHandler((event) => {
  const config = useRuntimeConfig()
  
  // 在服务端可以安全地访问私有配置
  console.log('API Secret:', config.apiSecret)
  
  return {
    message: '配置已加载'
  }
})
```

## 示例代码

### 示例 1: 完整的环境配置系统

```typescript
// types/config.ts
declare module '@nuxt/schema' {
  interface RuntimeConfig {
    apiSecret: string
    databaseUrl: string
    redis: {
      host: string
      port: number
    }
  }
  
  interface PublicRuntimeConfig {
    apiBase: string
    appName: string
    features: {
      chat: boolean
      darkMode: boolean
    }
  }
}

// nuxt.config.ts
export default defineNuxtConfig({
  runtimeConfig: {
    apiSecret: '',
    databaseUrl: '',
    redis: {
      host: '',
      port: 6379
    },
    
    public: {
      apiBase: '',
      appName: '超级应用',
      features: {
        chat: true,
        darkMode: true
      }
    }
  }
})

// composables/useApi.ts
export function useApi() {
  const config = useRuntimeConfig()
  
  return {
    async fetch(endpoint: string, options = {}) {
      const response = await $fetch(`${config.public.apiBase}${endpoint}`, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        }
      })
      return response
    }
  }
}
```

### 示例 2: 特性开关系统

```typescript
// composables/useFeatures.ts
export function useFeatures() {
  const config = useRuntimeConfig()
  
  const isFeatureEnabled = (featureName: keyof typeof config.public.features) => {
    return config.public.features[featureName] ?? false
  }
  
  return {
    isFeatureEnabled,
    // 特定特性的快捷方法
    isChatEnabled: () => isFeatureEnabled('chat'),
    isDarkModeEnabled: () => isFeatureEnabled('darkMode')
  }
}

// components/ChatWidget.vue
<template>
  <div v-if="isChatEnabled()">
    <h3>实时聊天</h3>
    <!-- 聊天组件内容 -->
  </div>
</template>

<script setup>
const { isChatEnabled } = useFeatures()
</script>
```

### 示例 3: 环境感知的配置管理器

```typescript
// utils/config-manager.ts
export class ConfigManager {
  private static instance: ConfigManager
  private config: RuntimeConfig
  
  private constructor() {
    this.config = useRuntimeConfig()
  }
  
  static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager()
    }
    return ConfigManager.instance
  }
  
  getApiUrl(endpoint: string): string {
    return `${this.config.public.apiBase}${endpoint}`
  }
  
  isDevelopment(): boolean {
    return process.env.NODE_ENV === 'development'
  }
  
  isProduction(): boolean {
    return process.env.NODE_ENV === 'production'
  }
  
  getFeatureFlag(key: string): boolean {
    return this.config.public.features[key] ?? false
  }
}

// 使用示例
const configManager = ConfigManager.getInstance()
const apiUrl = configManager.getApiUrl('/users')
```

## 常见坑点与注意事项

### 环境变量命名
-   **前缀规则**: 
    -   使用 `NUXT_` 前缀的环境变量会自动映射到运行时配置
    -   使用 `NUXT_PUBLIC_` 前缀的变量会暴露给客户端
-   **命名约定**: 使用大写字母和下划线，例如 `NUXT_API_SECRET`

### 安全性考虑
-   **敏感信息**: 
    -   永远不要将包含敏感信息的 `.env` 文件提交到版本控制
    -   使用 `.env.example` 作为模板
    -   在生产环境使用环境变量或密钥管理服务
-   **客户端暴露**: 
    -   确保敏感配置只在 `runtimeConfig` 的根级别定义，而不是在 `public` 中
    -   定期审查客户端暴露的配置

### 类型安全
-   **类型定义**: 为运行时配置添加 TypeScript 类型定义
-   **类型检查**: 使用 TypeScript 的严格模式确保类型安全

### 最佳实践
1.  **环境文件组织**:
    ```
    .env                # 基础配置
    .env.development    # 开发环境配置
    .env.test          # 测试环境配置
    .env.production    # 生产环境配置
    .env.example       # 示例配置（用于版本控制）
    ```

2.  **配置验证**:
    ```typescript
    // plugins/config-validator.ts
    export default defineNuxtPlugin(() => {
      const config = useRuntimeConfig()
      
      // 验证必需的配置
      if (!config.public.apiBase) {
        throw new Error('必需的配置 NUXT_PUBLIC_API_BASE 未设置')
      }
    })
    ```

3.  **开发工具集成**:
    ```typescript
    // 在开发环境显示配置信息
    if (process.dev) {
      console.log('运行时配置:', useRuntimeConfig())
    }
    ```

## 参考链接
-   [Nuxt4 官方文档 - 运行时配置](https://nuxt.com/docs/guide/going-further/runtime-config)
-   [Nuxt4 官方文档 - 环境变量](https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables)
-   [dotenv 文档](https://github.com/motdotla/dotenv#readme)