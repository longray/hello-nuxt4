# Nuxt4 性能优化：代码分割与懒加载
标签: Nuxt4, 性能优化, 代码分割, 懒加载, Web Vitals

## 问题描述
随着应用功能的增加，JavaScript 包体越来越大，导致初始加载时间变长，影响用户体验和核心 Web 指标（Core Web Vitals）。如何有效地对代码进行分割，实现按需加载和懒加载，以优化 Nuxt4 应用的性能？

## 解决方案
Nuxt4 基于 Vite 和 Vue 3，提供了强大的代码分割和懒加载能力。大部分情况下，Nuxt 会自动进行优化，但我们仍然可以通过一些策略来进一步提升性能。

### 1. 路由级别的代码分割 (自动)
Nuxt4 默认就会对每个页面（Page）进行代码分割。当你访问一个新页面时，该页面对应的 JavaScript 和 CSS 才会被加载。这是最基础也是最重要的性能优化手段。

### 2. 组件懒加载
对于不在首屏、体积较大或不总是需要立即显示的组件，可以进行懒加载。

#### a. 使用 `Lazy` 前缀
最简单的方式是在组件名前加上 `Lazy` 前缀。Nuxt 会自动将该组件及其依赖项分割成一个独立的 chunk，并在组件即将进入视口时才加载它。

```vue
<template>
  <div>
    <h1>我的主页</h1>
    <p>一些初始内容...</p>
    
    <!-- 这个重量级评论组件只在用户滚动到它附近时才加载 -->
    <LazyCommentsSection />
  </div>
</template>
```

#### b. 使用 `defineAsyncComponent`
对于更精细的控制，可以使用 Vue 的 `defineAsyncComponent`。

```vue
<template>
  <div>
    <button @click="showModal = true">打开重量级模态框</button>
    <HeavyModal v-if="showModal" @close="showModal = false" />
  </div>
</template>

<script setup>
import { defineAsyncComponent } from 'vue';

const showModal = ref(false);

// 异步加载组件
const HeavyModal = defineAsyncComponent(() => 
  import('@/components/HeavyModal.vue')
);
</script>
```

你还可以为异步组件提供加载状态和错误状态。

```typescript
const HeavyModal = defineAsyncComponent({
  loader: () => import('@/components/HeavyModal.vue'),
  loadingComponent: LoadingSpinner, // 加载时显示的组件
  errorComponent: ErrorDisplay,     // 加载失败时显示的组件
  delay: 200,                       // 延迟显示加载组件的时间 (ms)
  timeout: 3000,                    // 超时时间 (ms)
});
```

### 3. 客户端组件 (`<ClientOnly>`)
对于那些完全不需要在服务端渲染（SSR）的组件（例如，依赖浏览器特定 API 的图表库），可以使用 `<ClientOnly>` 组件包裹。这不仅可以避免 SSR 错误，还能将该组件的代码从初始的服务端渲染包中移除。

```vue
<template>
  <div>
    <h1>仪表盘</h1>
    <ClientOnly>
      <!-- 这个图表组件只会在客户端渲染 -->
      <InteractiveChart />
      
      <template #fallback>
        <!-- 可选：在服务端渲染时显示的占位内容 -->
        <div class="chart-placeholder">图表加载中...</div>
      </template>
    </ClientOnly>
  </div>
</template>
```

### 4. 动态导入 (Dynamic Imports)
在你的逻辑代码中，可以使用 `import()` 语法来动态加载模块。这对于处理用户交互触发的、非紧急的功能模块非常有用。

```vue
<script setup>
async function generateReport() {
  // 仅在用户点击按钮时才加载这个庞大的 PDF 生成库
  const { jsPDF } = await import('jspdf');
  
  const doc = new jsPDF();
  doc.text("你好，世界!", 10, 10);
  doc.save("report.pdf");
}
</script>
```

### 5. Vite 的手动分块 (Manual Chunks)
对于更高级的场景，你可以直接利用 Vite 的构建配置 `build.rollupOptions.output.manualChunks` 来手动指定代码分块策略。例如，将所有来自 `node_modules` 的库打包到一个单独的 `vendor` 文件中。

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  vite: {
    build: {
      rollupOptions: {
        output: {
          manualChunks(id) {
            if (id.includes('node_modules')) {
              // 将所有第三方库打包到 vendor chunk
              return 'vendor';
            }
          }
        }
      }
    }
  }
})
```

## 常见坑点与注意事项

-   **过度分割 (Over-splitting)**:
    -   不要滥用代码分割。创建太多的小 chunk 会增加 HTTP 请求的数量，在 HTTP/1.1 环境下可能会降低性能。虽然 HTTP/2 缓解了这个问题，但过多的请求仍然会带来开销。
    -   **策略**：将功能相关、且经常一起使用的模块打包在一起。

-   **懒加载的 UX**:
    -   对于懒加载的组件，一定要提供一个良好的加载状态（如骨架屏或加载指示器），否则用户可能会看到内容突然跳入，或者在慢速网络下感到困惑。

-   **`<ClientOnly>` 不是懒加载**:
    -   `<ClientOnly>` 的主要作用是防止组件在 SSR 期间渲染。它包裹的组件的 JavaScript **仍然会包含在初始加载的包里**，只是执行被推迟到了客户端挂载阶段。如果你想延迟加载它的代码，需要结合 `defineAsyncComponent` 或 `Lazy` 前缀。

-   **分析打包结果**:
    -   使用 `rollup-plugin-visualizer` 这样的工具来分析你的生产构建包，可以清晰地看到哪些模块占用了最大的空间，从而有针对性地进行优化。
    -   **安装**：`npm install -D rollup-plugin-visualizer`
    -   **配置**：
        ```typescript
        // nuxt.config.ts
        import { visualizer } from 'rollup-plugin-visualizer';

        export default defineNuxtConfig({
          vite: {
            plugins: [
              visualizer({ open: true }) // 在构建后自动打开分析报告
            ]
          }
        })
        ```

## 参考链接
-   [Nuxt4 官方文档 - 懒加载组件](https://nuxt.com/docs/guide/performance/lazy-loading-components)
-   [Nuxt4 官方文档 - 客户端组件](https://nuxt.com/docs/api/components/client-only)
-   [Vue.js 官方文档 - 异步组件](https://vuejs.org/guide/components/async.html)
-   [Vite 官方文档 - `manualChunks`](https://vitejs.dev/config/build-options.html#build-rollupoptions)