# 项目规则库

---

## 规则 1：新示例“清盘”规则

**一句话原则**：只删代码，不碰基建。

**执行时机**: 当我理解您要开始一个新示例时，此规则将自动触发。

**核心操作**:

1.  **识别目标**: 精准识别并列出所有**业务代码**目录，包括：
    - `components/`
    - `composables/`
    - `layouts/`
    - `middleware/`
    - `pages/`
    - `plugins/`
    - `server/`
    - `stores/`

2.  **彻底删除**: 调用操作系统原生命令，对上述目录执行“斩草除根”式删除，确保文件夹及其所有内容被完全移除。
    - **执行方式**: 使用 `Remove-Item -Recurse -Force` (Windows) 或 `rm -rf` (Linux/macOS) 命令。

3.  **严格保留**: 以下**项目基建**目录和文件**必须保留**，不受任何影响：
    - **框架相关**: `.nuxt/`, `node_modules/`, `pnpm-lock.yaml`
    - **静态资源**: `assets/`, `public/`
    - **项目配置**: `nuxt.config.ts`, `package.json`, 等所有配置文件。
    - **项目管理**: `.git/`, `.ai_memory/`, 等所有隐藏的管理目录。

**最终目标**: 每次清盘后，项目恢复到一个仅包含“基础设施”的纯净状态，为新示例的开发扫清障碍。

---

## 规则 2：示例验证与问题追踪规则

**一句话原则**：凡有产出，必有验证；凡有问题，必有记录。

**执行时机**: 当我完成一个示例的所有编码任务后，此规则自动触发。

**核心流程**:

1.  **我 (AI) - 请求验证**: 我会明确告知您示例已完成，并请求您进行手动验证。

2.  **您 (用户) - 手动验证**: 您根据示例目标，启动开发服务器 (`pnpm dev`) 或执行相关操作，在浏览器或终端中检查实际运行结果是否符合预期。

3.  **您 (用户) - 反馈结果**: 您向我反馈验证结果，只有两种标准回复：
    - `"验证成功"`: 如果功能符合预期。
    - `"验证失败"`: 如果功能不符合预期，请附上**问题描述**（例如：期望看到什么，实际发生了什么，报错信息截图等）。

4.  **我 (AI) - 处理反馈**:
    - **对于“验证成功”**: 我将确认并清空当前任务列表，等待您的下一个指令。
    - **对于“验证失败”**:
        - 我将生成一个唯一的 `issueId`。
        - 使用 `mcp_MongoDB_insert_many` 工具，在 `nuxt4` 数据库的 `issues` 集合中创建一个新的文档。
        - 该文档将至少包含 `issueId`、您提供的 `问题描述`、`相关代码快照`、`时间戳`，并标记 `verified: false`。
        - 我将基于这条新生成的 `issue` 记录，开始进行分析和调试。

**最终目标**: 建立一个从开发、测试、反馈到问题修复和知识沉淀的完整闭环，确保我们的经验库（`issues` 集合）越来越有价值。

---

## 规则 3：任务计划与执行规则 (v2.1 - 引入显式状态追踪)

**一句话原则**：谋定而后动，行而有方，败而有策，事毕有沉淀。

**执行时机**: 在每个新的 Nuxt 示例或主题开始时，此规则自动触发。

**核心流程**:

1.  **我 (AI) - 生成计划**: 基于您的新需求，我将使用标准模板在 `.ai_memory/task.md` 文件中生成一份详细的任务计划。
    - **回顾**：总结上一个计划的成果与关联的 Issues。
    - **当前**：明确本次计划的**核心目标**、关联的**知识库文档**，以及一份详细的、可追踪的**任务清单**。每个任务项将包含元数据：`状态: [待办]`, `对话计数: 0`, `失败阈值: 5`。
    - **展望**：预留下一个计划的方向。

2.  **您 (用户) - 确认计划**: 您审阅并确认任务计划。一旦确认，此计划将成为我们本次行动的“唯一剧本”。

3.  **我 (AI) - 循环执行与汇报 (The Loop)**:
    - **a. 宣告任务状态 (响应开始)**: 在我响应您的任何内容之前，**必须**首先读取 `task.md`，定位到当前活动任务，并在回复的开头明确宣告：`"正在执行任务：<任务名称>，当前对话次数：<次数>。"`
    - **b. 执行核心操作**: 我将严格按照任务描述执行操作（编码、分析、修复等）。
    - **c. 更新并汇报任务状态 (响应结束)**: 所有核心操作完成后，在回复的结尾，**必须**执行以下步骤：
        - **i. 计算新次数**: `新对话次数 = 当前对话次数 + 1`。
        - **ii. 准备更新**: 准备好更新 `.ai_memory/task.md` 文件。
        - **iii. 宣告更新**: 明确宣告：`"任务‘<任务名称>’的对话次数已更新为：<新对话次数>。正在将此变更写入任务计划..."`
        - **iv. 执行更新**: 立即调用文件更新工具，将对应任务的 `对话计数` 更新为 `新对话次数`，并根据执行结果更新 `状态`（`[x]` 或 `[!]`）和 `执行记录`。

4.  **我 (AI) - 失败熔断机制 (Circuit Breaker)**:
    - 在更新任务状态时，我**必须**检查 `对话计数` 是否已达到 `失败阈值` (默认为 **5**)。
    - **一旦触发阈值**:
        - **a. 挂起任务**: 我会将当前任务状态标记为 `[!]` (已挂起)，并停止在该任务上的所有常规操作。
        - **b. 启动子流程**: 我会立即启动一个高优先级的“**问题处理子流程**”，该流程本身也将作为一个特殊任务记录在 `task.md` 中。
        - **c. 执行子流程**: 该子流程严格遵循《智能体记忆核心交互规范.md》中的“信息检索与决策流程”：
            1.  检索本地知识库 (`.ai_memory/nuxt4-knowledge/`)
            2.  检索内部经验库 (`issues` 集合)
            3.  查阅官方文档 (`nuxt.com/docs`)
            4.  交叉验证 (GitHub, StackOverflow)
        - **d. 子流程决策**:
            - **解决问题**: 如果子流程找到解决方案，我会创建一个新任务来应用该方案，并在成功后，将原先挂起的任务重新激活。
            - **无法解决**: 如果穷尽所有手段仍无法解决，我将明确向您报告“子流程失败”，总结所有尝试和发现，并请求您的介入和帮助。

5.  **我 (AI) - 总结与归档**:
    - 当所有任务都标记为 `[x]` 后，我将提交“**当前计划总结报告**”。
    - 报告通过后，我将执行“规则1：清盘”，为下一个计划做准备。

**最终目标**: 建立一个包含“计划-宣告-执行-更新-反馈-熔断-修复”的完整、透明、健壮的工作闭环，确保我们不会在任何单一问题上无限循环，并能系统性地攻克难题。